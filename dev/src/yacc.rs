//
// Copyright (c) 2024 Jeff Garzik
//
// This file is part of the posixutils-rs project covered under
// the MIT License.  For the full license text, please see the LICENSE
// file in the root directory of this project.
// SPDX-License-Identifier: MIT
//

extern crate clap;
extern crate plib;

use clap::Parser;
use gettextrs::{bind_textdomain_codeset, textdomain};
use plib::PROJECT_NAME;
use std::collections::HashMap;
use std::fs;
use std::path::PathBuf;

/// yacc - yet another compiler compiler
#[derive(Parser, Debug)]
#[command(author, version, about, long_about)]
struct Args {
    /// Use file_prefix instead of y as the prefix for all output filenames.
    #[arg(short = 'b', long, default_value = "y")]
    file_prefix: String,

    /// Write the header file; by default only the code file is written
    #[arg(short = 'd', long)]
    header: bool,

    /// Produce a code file that does not contain any #line constructs.
    #[arg(short = 'l', long)]
    no_lines: bool,

    /// Use sym_prefix instead of yy as the prefix for all external names
    #[arg(short = 'p', long, default_value = "yy")]
    sym_prefix: String,

    /// Modify conditional compilation directives to permit compilation of debugging code
    #[arg(short = 't', long)]
    enable_debug: bool,

    /// Write a file containing a description of the parser and a report of conflicts generated by ambiguities in the grammar.
    #[arg(short, long)]
    verbose: bool,

    /// A pathname of a file containing instructions, hereafter called grammar, for which a parser is to be created.
    grammar: PathBuf,
}

#[derive(Debug, PartialEq)]
enum YFToken {
    Identifier(String),
    CIdentifier(String),
    Number(String),
    ReservedWord(String),
    Literal(String, bool), // `true` for string literals, `false` for char literals
    Mark,                  // %%
    LCurl,                 // {
    RCurl,                 // }
    PercentLCurl,          // %{
    PercentRCurl,          // %}
    Text(String),          // For capturing C code and union declarations
    Colon,                 // :
    Pipe,                  // |
    Semicolon,             // ;
}

// Parse a single token from a string
fn parse_token(value: &str) -> YFToken {
    // Check for string or character literals
    if value.starts_with("\"") && value.ends_with("\"") && value.len() > 1 {
        return YFToken::Literal(value[1..value.len() - 1].to_string(), true); // String literal
    } else if value.starts_with("'") && value.ends_with("'") && value.len() > 1 {
        return YFToken::Literal(value[1..value.len() - 1].to_string(), false); // Character literal
    }

    // Existing conditions for other token types
    if value.starts_with("%") {
        YFToken::ReservedWord(value.to_string())
    } else if value.chars().all(char::is_numeric) {
        YFToken::Number(value.to_string())
    } else if value.ends_with(':') {
        YFToken::CIdentifier(value[..value.len() - 1].to_string())
    } else {
        YFToken::Identifier(value.to_string())
    }
}

// Lex the input string into tokens
fn lex_yacc_input(input: &str) -> Vec<YFToken> {
    let mut tokens = Vec::new();
    let mut current = String::new();
    let mut chars = input.chars().peekable();
    let mut brace_depth = 0;
    let mut in_percent_brace_block = false;
    let mut n_marks = 0;

    while let Some(c) = chars.next() {
        if n_marks >= 2 {
            current.push(c);
        } else if in_percent_brace_block {
            if c == '%' && chars.peek() == Some(&'}') {
                chars.next();
                tokens.push(YFToken::Text(current.clone()));
                current.clear();
                tokens.push(YFToken::PercentRCurl);
                in_percent_brace_block = false;
            } else {
                current.push(c);
            }
        } else if brace_depth > 0 {
            if c == '}' {
                brace_depth -= 1;
                if brace_depth == 0 {
                    tokens.push(YFToken::Text(current.clone()));
                    current.clear();
                    tokens.push(YFToken::RCurl);
                } else {
                    current.push(c);
                }
            } else {
                if c == '{' {
                    brace_depth += 1;
                }
                current.push(c);
            }
        } else {
            match c {
                ' ' | '\n' | '\t' | '\r' => {
                    if !current.is_empty() {
                        tokens.push(parse_token(&current));
                        current.clear();
                    }
                }
                ':' | '|' | ';' => {
                    if !current.is_empty() {
                        tokens.push(parse_token(&current));
                        current.clear();
                    }
                    match c {
                        ':' => tokens.push(YFToken::Colon),
                        '|' => tokens.push(YFToken::Pipe),
                        ';' => tokens.push(YFToken::Semicolon),
                        _ => unreachable!(),
                    }
                }
                '%' => {
                    if !current.is_empty() {
                        tokens.push(parse_token(&current));
                        current.clear();
                    }
                    if chars.peek() == Some(&'%') {
                        chars.next(); // Consume the second %
                        tokens.push(YFToken::Mark); // This is the '%%' token
                        n_marks += 1;
                    } else if chars.peek() == Some(&'{') {
                        chars.next();
                        tokens.push(YFToken::PercentLCurl);
                        in_percent_brace_block = true;
                    } else {
                        let mut directive = String::from("%");
                        while let Some(&ch) = chars.peek() {
                            if ch.is_whitespace() {
                                break;
                            }
                            directive.push(ch);
                            chars.next();
                        }
                        tokens.push(YFToken::ReservedWord(directive));
                    }
                }
                '{' => {
                    if !current.is_empty() {
                        tokens.push(parse_token(&current));
                        current.clear();
                    }
                    tokens.push(YFToken::LCurl);
                    brace_depth = 1;
                }
                '}' => {
                    tokens.push(YFToken::RCurl);
                }
                _ => current.push(c),
            }
        }
    }

    // Handle any remaining characters as a token
    if !current.is_empty() {
        if n_marks >= 2 {
            tokens.push(YFToken::Text(current.clone()));
        } else {
            tokens.push(parse_token(&current));
        }
    }

    tokens
}

#[derive(Debug, Clone, PartialEq, Eq)]
enum Associativity {
    Left,
    Right,
    NonAssoc,
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct Token {
    name: String,
    typetag: Option<String>,
    token_number: Option<usize>,
}

#[derive(Debug, Clone)]
struct Symbol {
    kind: SymbolKind,
    name: String,
    typetag: Option<String>, // Now Symbols can also have type tags
}

#[derive(Debug, Clone, PartialEq, Eq)]
enum SymbolKind {
    Terminal,
    NonTerminal,
}

#[derive(Debug, Clone)]
struct Production {
    head: Symbol, // Changed from String to Symbol to include type tag
    body: Vec<Symbol>,
    action: Option<String>,
}

#[derive(Debug, Clone)]
struct Precedence {
    level: usize,
    associativity: Associativity,
    tokens: Vec<Token>,
}

#[derive(Debug, Clone)]
struct Grammar {
    start_symbol: String,
    symbols: HashMap<String, Symbol>, // Tracks both terminals and non-terminals
    precedences: Vec<Precedence>,
    productions: Vec<Production>,
    tail: String,
}

impl Grammar {
    fn new() -> Self {
        Grammar {
            start_symbol: String::new(),
            symbols: HashMap::new(),
            precedences: Vec::new(),
            productions: Vec::new(),
            tail: String::new(),
        }
    }

    fn add_production(&mut self, head: Symbol, body: Vec<Symbol>, action: Option<String>) {
        let production = Production { head, body, action };
        self.productions.push(production);
    }

    fn add_symbol(&mut self, name: String, kind: SymbolKind, typetag: Option<String>) {
        let symbol = Symbol {
            kind,
            name: name.clone(),
            typetag,
        };
        self.symbols.insert(name, symbol);
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // parse command line arguments
    let args = Args::parse();

    textdomain(PROJECT_NAME)?;
    bind_textdomain_codeset(PROJECT_NAME, "UTF-8")?;

    let raw_input = fs::read_to_string(&args.grammar)?;
    let tokens = lex_yacc_input(&raw_input);
    println!("{:#?}", tokens);

    Ok(())
}
