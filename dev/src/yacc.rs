//
// Copyright (c) 2024 Jeff Garzik
//
// This file is part of the posixutils-rs project covered under
// the MIT License.  For the full license text, please see the LICENSE
// file in the root directory of this project.
// SPDX-License-Identifier: MIT
//

extern crate clap;
extern crate plib;

use clap::Parser;
use gettextrs::{bind_textdomain_codeset, textdomain};
use plib::PROJECT_NAME;
use std::fs;
use std::path::PathBuf;

/// yacc - yet another compiler compiler
#[derive(Parser, Debug)]
#[command(author, version, about, long_about)]
struct Args {
    /// Use file_prefix instead of y as the prefix for all output filenames.
    #[arg(short = 'b', long, default_value = "y")]
    file_prefix: String,

    /// Write the header file; by default only the code file is written
    #[arg(short = 'd', long)]
    header: bool,

    /// Produce a code file that does not contain any #line constructs.
    #[arg(short = 'l', long)]
    no_lines: bool,

    /// Use sym_prefix instead of yy as the prefix for all external names
    #[arg(short = 'p', long, default_value = "yy")]
    sym_prefix: String,

    /// Modify conditional compilation directives to permit compilation of debugging code
    #[arg(short = 't', long)]
    enable_debug: bool,

    /// Write a file containing a description of the parser and a report of conflicts generated by ambiguities in the grammar.
    #[arg(short, long)]
    verbose: bool,

    /// A pathname of a file containing instructions, hereafter called grammar, for which a parser is to be created.
    grammar: PathBuf,
}

#[derive(Debug, PartialEq)]
enum Token {
    Identifier(String),
    CIdentifier(String),
    Number(String),
    ReservedWord(String),
    Literal(String, bool), // `true` for string literals, `false` for char literals
    Mark,                  // %%
    LCurl,                 // {
    RCurl,                 // }
    PercentLCurl,          // %{
    PercentRCurl,          // %}
    Text(String),          // For capturing C code and union declarations
}

// Parse a single token from a string
fn parse_token(value: &str) -> Token {
    // Check for string or character literals
    if value.starts_with("\"") && value.ends_with("\"") && value.len() > 1 {
        return Token::Literal(value[1..value.len() - 1].to_string(), true); // String literal
    } else if value.starts_with("'") && value.ends_with("'") && value.len() > 1 {
        return Token::Literal(value[1..value.len() - 1].to_string(), false); // Character literal
    }

    // Existing conditions for other token types
    if value.starts_with("%") {
        Token::ReservedWord(value.to_string())
    } else if value.chars().all(char::is_numeric) {
        Token::Number(value.to_string())
    } else if value.ends_with(':') {
        Token::CIdentifier(value[..value.len() - 1].to_string())
    } else {
        Token::Identifier(value.to_string())
    }
}

// Lex the input string into tokens
fn lex_yacc_input(input: &str) -> Vec<Token> {
    let mut tokens = Vec::new();
    let mut current = String::new();
    let mut chars = input.chars().peekable();
    let mut brace_depth = 0;
    let mut in_percent_brace_block = false;

    while let Some(c) = chars.next() {
        if in_percent_brace_block {
            if c == '%' && chars.peek() == Some(&'}') {
                chars.next();
                tokens.push(Token::Text(current.clone()));
                current.clear();
                tokens.push(Token::PercentRCurl);
                in_percent_brace_block = false;
            } else {
                current.push(c);
            }
        } else if brace_depth > 0 {
            if c == '}' {
                brace_depth -= 1;
                if brace_depth == 0 {
                    tokens.push(Token::Text(current.clone()));
                    current.clear();
                    tokens.push(Token::RCurl);
                } else {
                    current.push(c);
                }
            } else {
                if c == '{' {
                    brace_depth += 1;
                }
                current.push(c);
            }
        } else {
            match c {
                ' ' | '\n' | '\t' | '\r' => {
                    if !current.is_empty() {
                        tokens.push(parse_token(&current));
                        current.clear();
                    }
                }
                '%' => {
                    if !current.is_empty() {
                        tokens.push(parse_token(&current));
                        current.clear();
                    }
                    if chars.peek() == Some(&'%') {
                        chars.next(); // Consume the second %
                        tokens.push(Token::Mark); // This is the '%%' token
                    } else if chars.peek() == Some(&'{') {
                        chars.next();
                        tokens.push(Token::PercentLCurl);
                        in_percent_brace_block = true;
                    } else {
                        let mut directive = String::from("%");
                        while let Some(&ch) = chars.peek() {
                            if ch.is_whitespace() {
                                break;
                            }
                            directive.push(ch);
                            chars.next();
                        }
                        tokens.push(Token::ReservedWord(directive));
                    }
                }
                '{' => {
                    if !current.is_empty() {
                        tokens.push(parse_token(&current));
                        current.clear();
                    }
                    tokens.push(Token::LCurl);
                    brace_depth = 1;
                }
                '}' => {
                    tokens.push(Token::RCurl);
                }
                _ => current.push(c),
            }
        }
    }

    // Handle any remaining characters as a token
    if !current.is_empty() {
        tokens.push(parse_token(&current));
    }

    tokens
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    // parse command line arguments
    let args = Args::parse();

    textdomain(PROJECT_NAME)?;
    bind_textdomain_codeset(PROJECT_NAME, "UTF-8")?;

    let raw_input = fs::read_to_string(&args.grammar)?;
    let tokens = lex_yacc_input(&raw_input);
    println!("{:#?}", tokens);

    Ok(())
}
